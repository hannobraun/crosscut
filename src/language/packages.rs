use std::collections::BTreeMap;

#[derive(Debug)]
pub struct Packages {
    inner: Vec<RegisteredPackage>,
    next_id: PackageId,
}

impl Packages {
    pub fn new() -> Self {
        Self {
            inner: Vec::new(),
            next_id: PackageId { id: 0 },
        }
    }

    pub fn new_package<T>(&mut self) -> PackageBuilder<T> {
        self.inner.push(RegisteredPackage {
            function_ids_by_name: BTreeMap::new(),
            function_names_by_id: BTreeMap::new(),
        });

        let Some(package) = self.inner.last_mut() else {
            unreachable!(
                "Just pushed a package, so a last package must exist."
            );
        };

        self.next_id.id += 1;

        PackageBuilder {
            functions_by_id: BTreeMap::new(),
            registered: package,
            next_id: FunctionId { id: 0 },
        }
    }

    pub fn register_package(&mut self) -> PackageId {
        self.next_id
    }

    pub fn resolve_function(&self, name: &str) -> Option<FunctionId> {
        self.inner
            .iter()
            .find_map(|package| package.function_ids_by_name.get(name).copied())
    }

    pub fn function_name_by_id(&self, id: &FunctionId) -> &str {
        let Some(name) = self
            .inner
            .iter()
            .find_map(|package| package.function_names_by_id.get(id))
        else {
            panic!("Expected function ID `{id:?}` to be valid.");
        };

        name
    }
}

pub struct PackageBuilder<'r, T> {
    registered: &'r mut RegisteredPackage,
    functions_by_id: BTreeMap<FunctionId, T>,
    next_id: FunctionId,
}

impl<T> PackageBuilder<'_, T> {
    pub fn add_function(&mut self, function: T) -> FunctionId
    where
        T: Function,
    {
        let id = self.next_id;
        self.next_id = FunctionId { id: id.id + 1 };

        self.registered
            .function_ids_by_name
            .insert(function.name().to_string(), id);
        self.registered
            .function_names_by_id
            .insert(id, function.name().to_string());

        self.functions_by_id.insert(id, function);

        id
    }

    pub fn build(self) -> Package<T> {
        Package {
            functions_by_id: self.functions_by_id,
        }
    }
}

#[derive(Debug)]
pub struct Package<T> {
    functions_by_id: BTreeMap<FunctionId, T>,
}

impl<T> Package<T> {
    pub fn function_by_id(&self, id: &FunctionId) -> &T {
        let Some(function) = self.functions_by_id.get(id) else {
            panic!(
                "This method expects to be passed only IDs that have been \
                generated by the same instance of `Package`."
            );
        };

        function
    }
}

#[derive(Debug)]
struct RegisteredPackage {
    function_ids_by_name: BTreeMap<String, FunctionId>,
    function_names_by_id: BTreeMap<FunctionId, String>,
}

pub trait Function: Copy + Ord {
    fn name(&self) -> &str;
}

#[derive(
    Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, udigest::Digestable,
)]
pub struct FunctionId {
    id: u32,
}

#[derive(
    Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd, udigest::Digestable,
)]
pub struct PackageId {
    id: u32,
}
