Yesterday, I defined [a simple protocol](/daily/2025-06-21) for converting from
one type to another. Here it is again:

```
Convert := protocol A, B {
	convert := fn A -> B
}
```

(Again, this is just pseudocode. Don't take the syntax too seriously.)

And here's how we could use that protocol in a function:

```
use Convert Int, String

convert_all := fn list: [Int] -> [String] {
	// implementation goes here
}
```

Here we declare that we're going to use the `Convert` protocol in the local
context, for the types `Int` and `String` (which correspond to `A` and `B` in
the protocol definition above). Assuming that `Convert` is implemented for this
combination of types, we can use this implementation in the `convert_all`
function to convert a whole list of values.

This isn't very interesting yet. All we're doing is using functions on
statically known types, and we wouldn't need a protocol for that. Any means of
importing those functions into the local scope would do. The purpose of this
example is just to ease into a more complicated one, which I'll show you
tomorrow.
