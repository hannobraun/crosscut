Yesterday's example showed the first real
[use of a protocol](/daily/2025-06-23). Especially interesting was how
multi-type protocols need to be used differently from single-type traits. And I
could have done this differently, by mentioning the module on the level of the
function. But I didn't. I defined it above the function level, the scope of the
current module.

And I did that because I think it leads to something interesting: The way I'm
declaring the use of the protocol kinda looks as if I'm importing a module
there. And if you think about that, isn't that what protocols could be? Generic
modules, that accept the types they abstract over as parameters?

And of course, I'm not the one to invent this concept. [OCaml] already does it!
And I think it's very neat. Having modules that can have parameters seems like a
natural extension of what modules typically are in most languages. And if you
can cover a new use case without having to introduce a totally new feature, then
that seems like a potential win!

[OCaml]: https://ocaml.org/
