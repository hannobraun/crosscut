Yesterday, I showed a use of a protocol that
[wasn't very interesting yet](/daily/2025-06-22). There's really no point in
protocols (or traits), if all you do is operate on known types. They are tools
of abstraction that are useful where you _don't_ know the types you work with,
so you may write code that can work with many of them.

First, here's our example protocol again, to make sure we're on the same page:

```
Convert := protocol A, B {
    convert := fn A -> B
}
```

Here's what using it as described above could then look like (again, just
pseudocode; don't take the syntax too seriously):

```
with A, B use Convert A, B

convert_all := fn values: [A] -> [B] {
	values.map
		fn value { convert value }
}
```

So instead of using `Convert` with concrete types, like we did yesterday, we
declare that there are two abstract types, `A` and `B`, and that we expect the
`Convert` protocol to be available for those. Afterwards, we use the abstract
types to declare a function, `convert_all`, within which we use `convert` from
the protocol.

What's interesting here, is that we need to use protocols differently
[than we did use traits](/daily/2025-06-15). A protocol is not tied to a single
type, so we can't just say "we expect this parameter to be an implementation of
this protocol". Instead, we need to define how a protocol relates to the
abstract types in our scope.
